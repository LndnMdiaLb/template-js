/* 
    Server Streamed Events Express Backend 

    SSE was designed as a simple, text-based and unidirectional transport.

    It only allows data reception from the server (unidirectional)
    Events are limited to UTF-8 (no binary data)
*/

class EventStreamMessage {
  /*  Event Stream protocol 
            event:
            id:
            retry:
            data:
        data - requires 2 newlines after string for event source to capture the event
    */

  constructor(data, event = null, id = null, retry = null) {
    this.payload = ``;
    this.create(data, event, id, retry);
  }

  /* data is pre requisite in this solution */
  create(data, event = null, id = null, retry = null) {
    // prettier-ignore
    /*  `data: ${data}\n\n`}` to close payload in that exact format is imperative */
    this.payload = `${!event?'':
            `event: ${event}\n`}${!id?'':
            `id: ${id}\n`}${!retry?'':
            `retry: ${retry}\n`}${!data?'':
            `data: ${data}\n\n`}`;
    return this.payload;
  }
}

const eventStreamMessage = new EventStreamMessage();

const bodyParser = require("body-parser");
const cors = require("cors");

let clients = [];

const dataStore = [];

const Dispatcher = (app) => {
  // Set cors and bodyParser middlewares
  app.use(cors());
  app.use(bodyParser.json());
  app.use(
    bodyParser.urlencoded({
      extended: false,
    })
  );

  /*
    curl -X POST \
        -H "Content-Type: application/json" \
        -d '{"momma": "swamp_princess", "eggs": 40, "temperature": 31}' \
        -s http://localhost:3001/emit

  */

  app.post("/emit", async (IncomingMessage, ServerResponse, next) => {
    const payload = IncomingMessage.body;
    dataStore.push(payload);

    // emit incoming data as POST result from /emit route (in this example curl above);
    ServerResponse.json(payload);

    /* 
        Iterate clients list for 
        ServerResponse objects (WritableStreams) instantiated by accessing /become-client route
        Server activation ( .listen(3001) ) also creates and maintains a closure while running 
        ServerResponses are stored in this closure for duration of server life
        We trigger a write on these stored data responses via /emit endpoint

        /emit endpoint triggers server responses to /become-client endpoint
    */

    function sendEventsToAll(payload) {
      const eventPayload = eventStreamMessage.create(JSON.stringify(payload));
      clients.forEach(({ ServerResponse: StoredResponse }) => {
        StoredResponse.write(eventPayload);
      });
    }

    // Invoke iterate and send function
    return sendEventsToAll(payload);
  });

  /*
      Open connection waiting updates
      curl  -H Accept:text/event-stream http://localhost:3001/become-client 
  */

  app.get("/become-client", (IncomingMessage, ServerResponse, next) => {
    ////////////////////

    //  <message.IncomingMessage>

    // Once navigate away from /become-client
    IncomingMessage.on("close", () => {
      // tell server
      console.log(`${clientId} Connection closed`);
      // remove client. incoming close means log off
      clients = clients.filter(({ id }) => id !== clientId);
    });

    ////////////////////

    //  <http.ServerResponse>

    /* 
        Mandatory headers and http status to keep connection open  
        limited only to UTF-8 
    */

    ServerResponse.writeHead(200, {
      "Content-Type": "text/event-stream",
      Connection: "keep-alive",
      "Cache-Control": "no-cache",
    });

    const payload = eventStreamMessage.create(
      JSON.stringify(dataStore),
      "initial-connection"
    );

    // oportunity to client that has accessed this live connection
    ServerResponse.write(payload);

    /*
            collect ServerResponse objects generated by client requests
            this objects provide access to specific Clients
        */

    const id = Date.now();
    clients.push({
      id,
      ServerResponse,
    });
  });
};

module.exports = Dispatcher;
